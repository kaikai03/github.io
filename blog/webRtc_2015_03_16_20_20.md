Title: webRtc 前端
Date: 2015-03-16 20:20
Modified: 2015-03-16 20:20
Category: 音视频
Tags: webRtc,JavaScript,html5
Slug: webRtc_2015_03_16_20_20
Authors: kai_kai03
Summary: 一个最简化操作的demo，写给研发同事学习用的。

## 简单说明 ##
主要流程就是：

1. 用getUserMedia 打开摄像头；
2. 通过iceServer中设置的stun服务器来获取当前设备的网络链路信息；
3. 用PeerConnection建立p2p；
4. 如果p2p无法连通，将使用iceServer中设置的turn服务器进行数据转发，当然demo里面没设置turn服务，后面有空我再写篇turn的安装和配置，挺简单的；

发起通话请求的用户会发送\_\_offer(含sdp)给平台（具体见前一篇），平台转发给被请求用户。被请求用户接受的话会返回\_\_answer(含sdp)给平台，平台呢再发送给发起请求的用户，两者确定关系后，两者通过平台交换跟自身设备相关的网络节点信息\_\_ice\_candidate，根据不同网络环境，这个交互的数量是不一定的，接下来就是设备自己去测试\_\_ice\_candidate中描述的网络节点，看走哪p2p能连通。如果都不能通就去走turn了。

其实平台不是必须的，只不过去掉平台的前提是两个通话者永远知道对方的位置（ip），并且两个设备之间网络保证是互通的，否者没有信令交互就没有后面的事。

## 注意 ##
截止到现在，safari、ie还不支持webRtc，不过快了，firefox里的webRtc是个半成品，并且不稳定，要用网页开发产品的话，最好是针对chrome，目前测试下来，最新版本的pc版与android版都很稳定。

不过不稳定的firefox有个好处，它能拍照录音（录像能不能忘了），而chrome安全级别很高，完全不允许录音录像。

## 代码 ##

	<!doctype html>
	<html lang="zh-CN">
	<head>
	  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	  <title>test1</title>
	  <style type="text/css">
	    html, body {
	      width: 100%;
	      height: 100%;
	      margin: 0;
	      padding: 0;
	      background-color: #f0f0f0;
	    }
	
	    #videos {
	      position: absolute;
	      left: 30%;
	      top: 0;
	      bottom: 0;
	      right: 0;
	      overflow: auto;
	    }
	
	    #videos video {
	      display: inline-block;
	      width: 30%;
	      background:"#000000";
	    }
	  </style>
	</head>
	<body>
	  <div id="btn">
	    <button id="sendtext" class="sendBtn"  style="width:50px;height:50px;">sendtextbySocket</button><br/>
	    <button id="createPeerConnectt" class="sendBtn">createPeerConnect</button><br/>
	    <button id="sendTextByFataChannel" class="sendBtn">sendTextByFataChannel</button>
	    
	  </div>
	  <div id="videos">
	    <video id="selfVideo"   autoplay></video>
	    <video id="remoteVideo" autoplay></video>
	    <video id="thirdRemoteVideo" autoplay></video>
	  </div>
	</body>
	
	<script type="text/javascript">
	var sendtextBtn = document.getElementById("sendtext");
	var createPeerConnectBtn = document.getElementById("createPeerConnectt");
	var sendTextByFataChannelBtn = document.getElementById('sendTextByFataChannel');
	
	var selfVideo = document.getElementById('selfVideo');
	var remoteVideo = document.getElementById('remoteVideo');
	var thirdRemoteVideo = document.getElementById('thirdRemoteVideo');
	
	
	
	///Adaptive browser variable
	var PeerConnection = (window.PeerConnection || window.webkitPeerConnection00 || window.webkitRTCPeerConnection || window.mozRTCPeerConnection);
	var URL = (window.URL || window.webkitURL || window.msURL || window.oURL);
	var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
	var nativeRTCIceCandidate = (window.mozRTCIceCandidate || window.RTCIceCandidate);
	var nativeRTCSessionDescription = (window.mozRTCSessionDescription || window.RTCSessionDescription); // order is very important: "RTCSessionDescription" defined in Nighly but useless
	var moz = !! navigator.mozGetUserMedia;
	
	var BlobBuilder = window.blobBuilder || window.webKitBlobBuilder || window.mozBlobBuilder;
	
	
	var iceServer = {
	        "iceServers": [{
	            "url": "stun:stun.ekiga.net"
	        }]
	    };
	//stun.l.google.com:19302
	//stun1.l.google.com:19302
	//stun2.l.google.com:19302
	//stun3.l.google.com:19302
	//stun4.l.google.com:19302
	//stun01.sipphone.com
	//stun.ekiga.net
	//stun.fwdnet.net
	//stun.ideasip.com
	//stun.iptel.org
	//stun.rixtelecom.se
	//stun.schlund.de
	//stunserver.org
	//stun.softjoys.com
	//stun.voiparound.com
	//stun.voipbuster.com
	//stun.voipstunt.com
	//stun.voxgratia.org
	//stun.xten.com
	//stun.voipbuster.com
	//stun.wirlab.net
	//stun.ideasip.com
	//stun.iptel.org
	//stun.schlund.de
	//numb.viagenie.ca
	//stun.voxgratia.org
	//stun.ekiga.net
	//stun.voipstunt.com
	//stunserver.org
	
	
	//self variable
	var selfStream = null;
	var selfPeerConnection = null;
	var cPeerConnection = null;
	var selfSession = null;
	var isCaller = false;
	var socket = null;
	var datachannel = null;
	var remoteVideoCompelet = false;
	var is2C = false;
	
	
	
	function saveAs(blob, filename) {
	    var type = blob.type;
	    var force_saveable_type = 'application/octet-stream';
	    if (type && type != force_saveable_type) { // 强制下载，而非在浏览器中打开
	        var slice = blob.slice || blob.webkitSlice || blob.mozSlice;
	        blob = slice.call(blob, 0, blob.size, force_saveable_type);
	    }
	 
	    var url = URL.createObjectURL(blob);
	    var save_link = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
	    save_link.href = url;
	    save_link.download = filename;
	 
	    var event = document.createEvent('MouseEvents');
	    event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
	    save_link.dispatchEvent(event);
	    URL.revokeObjectURL(url);
	}
	
	////peer function,and setup callback 
	function createPeerConnect(){
		console.log('createPeerConnect');
		var constraints = {
		    mandatory: {
		        OfferToReceiveAudio: true,
		        OfferToReceiveVideo: true 
		    },
		    optional:[
	        	{RtpDataChannels: true}
	        ]
		};
	
		pc = new PeerConnection(iceServer,constraints);
	
		pc.onicecandidate = function(evt) {
			console.log(evt);
			
			sendSession = selfSession;
			if(is2C){
				sendSession = "c";
			};
			
			if (evt.candidate){
				socket.send(JSON.stringify({
					"event": "__ice_candidate",
	    		"data": {
	          "candidate": evt.candidate,
	          "remoteSession":sendSession
	    		}
		     }));
		     console.log('onicecandidate sucess');
		    }else{
		   	console.log('onicecandidate error');
		  	};
			};
			
		pc.onopen = function() {
			console.log('pc open');
			};
	
		pc.onaddstream = function(event){
			console.log('pc get remote stream');
			v = null;
			if (!remoteVideoCompelet){
				v = remoteVideo 
				remoteVideoCompelet = true;
				console.log('pc get remote stream: remoteVideo');
			}else{//c
				v = thirdRemoteVideo
				console.log('pc get remote stream: thirdRemoteVideo');
			}
			v.src = window.URL.createObjectURL(event.stream);
			v.play();
			v.onloadedmetadata = function(e) {
	      console.log("Label: " + event.stream.label);
	      console.log("AudioTracks" , event.stream.getAudioTracks());
	      console.log("VideoTracks" , event.stream.getVideoTracks());
	    };
	    
		};
	
		pc.ondatachannel = function(evt) {
				console.log('pc ondatachannel');
			};
		return pc;
	};
	
	function closePeerConnection(pc) {
		if (!pc)return;
		pc.close();
	};
	
	
	
	
	////connect function to btn
	sendtextBtn.onclick = function(event){
		socket.send('socket sendsendsend ');
		console.log('send');
	 };
	 
	 sendTextByFataChannelBtn.onclick = function(event){
		dataChannel.send('dataChannel sendsendsend ');
		console.log('dataChannel send');
	 };
	 
	createPeerConnectBtn.onclick = function(event){
		console.log('createPeerConnectBtn.onclick',getUserMedia);
		
		
		
		////create and config peerConnection ,
	           // "googNoiseReduction": false
		///at the same time,open local camera and set the stream to 'video', "maxAspectRatio": "1.334" 
		getUserMedia.call(navigator, {
	  "video": {
	        "mandatory": { "minAspectRatio": 2.333,"maxAspectRatio": 2.334},
	        "optional" :[
	        	{"minFrameRate": 2},
	          { "maxWidth": 640 },
	          { "maxHeigth": 480}
	        ]
	      },
	  audio:{
	        mandatory: {
	            googEchoCancellation: true,
	            googEchoCancellation2: true,
	            googAutoGainControl: true,
	            googAutoGainControl2: true,
	            googNoiseSuppression: true,
	            googNoiseSuppression2: true,
	            googHighpassFilter: true  ,
	            googTypingNoiseDetection: true  
	        },
	        optional: [
	        		{adjustPeerVolume:true},
							{peerVolumeWhenSpeaking:1},
							{googNoiseReduction: true},
							{googTypingNoiseDetection: true},
	          	{googAudioMirroring: true}
							]
	    },
	  autoAdjustMic: true,
	  googCombinedAudioVideoBwe:true
		}, function(stream){
	 		//
		  var sendOfferFn = function(desc){
		      selfPeerConnection.setLocalDescription(desc);
		      socket.send(JSON.stringify({ 
		        "event": "__offer",
		        "data": {
		          "sdp": desc,
		          "remoteSession":selfSession
		        }
		      }));
		    }
		    //,
		  //sendAnswerFn = function(desc){
		  //    selfPeerConnection.setLocalDescription(desc);
		  //    socket.send(JSON.stringify({ 
		  //      "event": "__answer",
		  //      "data": {
		  //        "sdp": desc,
		  //        "remoteSession":selfSession
		  //      }}));
	    //	};
	    selfStream = stream;
	    console.log("selfStream: " + selfStream);
	    selfVideo.src = window.URL.createObjectURL(selfStream);
	    selfVideo.volume = 0
	    console.log("selfVideo.src: " + selfVideo.src);
	    
			selfVideo.onloadedmetadata = function(e) {
	      console.log("Label: " + selfStream.label);
	      console.log("AudioTracks" , selfStream.getAudioTracks());
	      console.log("VideoTracks" , selfStream.getVideoTracks());
	      
	    };
			//selfVideo.play();
	
			
			
	
	    
			
			selfPeerConnection.addStream(selfStream);
			
			dataChannel = selfPeerConnection.createDataChannel("label");
			dataChannel.onmessage = function (event) {
		   	console.log('dataChannel,onmessage:',event.data);
			};
			
			if(isCaller){
	    	selfPeerConnection.createOffer(sendOfferFn);
	  	} else {
	    	//selfPeerConnection.createAnswer(sendAnswerFn);
	  	}
			
	    },function(error){
	  			console.log('stream errpr',error);
			});
	};
	
	
	
	
	function StreamSave(blob) {
			var bb = new BlobBuilder;
			bb.append('Hello, world!');
			saveAs(bb.getBlob('text/plain;charset=utf-8'), 'hello world.txt');
	 };
	
	
	///connect to server
	socket = new WebSocket('ws://192.168.18.53:50000');
	socket.onopen = function(event) {
			//sucess callback,the next action would wait for it
		  console.log('open');
		  
		  selfPeerConnection = createPeerConnect();
			console.log(selfPeerConnection);
		
		  //listen port and message received callback 
		  socket.onmessage = function(event) {
		  	console.log('Client received a message:');
		  	console.log(event.data);
		  	try{
		  		var json = JSON.parse(event.data);
		  	}catch(e){
		  		console.log('is no json');
		  		return;
		  		}
		  	
		  	//junze create
				if(json.event === "_usersesion"){
					selfSession = json.data
					if(selfSession === "b" || selfSession === "c")
						isCaller = true
					console.log('isCaller',isCaller);
					return;
					};
				
				if( json.event === "__ice_candidate" ){
					pc = null;
					if(json.data.remoteSession === "c" && selfSession === "a"){
						pc = cPeerConnection;
		    	}else{
		    		pc = selfPeerConnection;
		    	}
		    	if(pc === cPeerConnection)
		    		console.log('pc === cPeerConnection');
		    		console.log(cPeerConnection);
		    	
		    	try{
			  		pc.addIceCandidate(new RTCIceCandidate(json.data.candidate));
			  	}catch(e){
			  		console.log('pc.addIceCandidate error',e);
			  		console.log('json.data',json.data)
			  		console.log('json.data.candidate',json.data.candidate)
			  	}
	    		
	    		return;
	  		} 
	  		if( json.event === "__offer" ) {
	  			pc = null;
	  			romoteSesson = json.data.remoteSession;
	  			if(json.data.remoteSession === "c"){
		    		cPeerConnection = createPeerConnect();
						console.log("cPc:",cPeerConnection);
						pc = cPeerConnection;
						is2C = true;
		    	}else{
		    		pc = selfPeerConnection;
		    	};
		    	
		    	if(is2C){
		    		sendSession = "c";
		    	}else{
		    		sendSession = selfSession;
		    	};
		    	
	     		pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp));
	     		
	     		sendAnswerFn = function(desc){
			      pc.setLocalDescription(desc);
			      socket.send(JSON.stringify({ 
			        "event": "__answer",
			        "data": {
			          "sdp": desc,
			          "remoteSession":sendSession
			        }}));
		    		};
		    	pc.createAnswer(sendAnswerFn);
	     		return;
	  		};
	  		
	  		if( json.event === "__answer") {
	     		selfPeerConnection.setRemoteDescription(new RTCSessionDescription(json.data.sdp));
	     		return;
	  		};
		  };
		  //close connect callback
		  socket.onclose = function(event) {
				console.log('Client notified socket has closed');
		  };
		  //close
		  //socket.close()
		};
		
		
	
	//var recordRTC = RecordRTC(stream, {
	//    type: 'video',
	//    canvas: {
	//        width: 1280,
	//        height: 720
	//    }
	//});
	
	</script>
	</html>
	
