Title: 音频相关零碎
Date: 2015-09-15 21:01
Modified: 2015-09-15 21:01
Category: 音视频
Tags: C++,audio
Slug: audio_2015_09_15_21_01
Authors: kai_kai03
Summary: map3、aac解码，wav解析，频谱绘制，PCM播放等

## for OBS ##
因为咪啪这个项目需要，写了个音频类给开发同事。
什么解码解析播放都是附带的，目的是那个绘制频谱。

大致逻辑是解码->得到pcm->采样->归一化->双声道混mono->渲染电平

最后为了能够进行预处理，不占用演奏初始化时间，加了个渲染出来的东西保存成文件。

最开始采样是放在后面的，后来发现对内存要求太高，所以干脆把采样放到前面去了。

	
	#include "Audio_tool_kk.h"

	//两个第三方库
	#include "decodeaac/decthread.h"
	#pragma comment (lib,"dsound.lib")
	#pragma comment(lib, "libmpg123.lib")
	
	#pragma once
	
	
	bool Audio_tool_kk::load_MP3_file(char *fname, audioData &audio)
	{
		FILE *fp;
	
		fp = fopen(fname, "rb");
		if (fp)
		{
			BYTE *buffer;
			int err = MPG123_OK;                               
			long rate = 0;
			int channels = 0, enc = 0, bits_per_sample=0;
	
	
			if (mpg123_init() != MPG123_OK)
			{
				Log(TEXT("MP3 decoder init error"));
				fclose(fp);
				return FALSE;
			}
			mpg123_handle *m = mpg123_new(NULL, &err);
			if (err != MPG123_OK)
			{
				Log(TEXT("MP3 decoder Create error"));
				mpg123_exit();
				fclose(fp);
				return FALSE;
			}
	
			if (mpg123_open(m, fname) != MPG123_OK)
			{
				Log(TEXT("MP3 open failse"));
				mpg123_delete(m);
				mpg123_exit();
				fclose(fp);
				return FALSE;
			}
	
			if ((err = mpg123_getformat(m, &rate, &channels, &enc)) == MPG123_OK)
			{
				/*  //maybe not support
				if (enc != MPG123_ENC_SIGNED_16 && enc != MPG123_ENC_FLOAT_32)
				{
					Log(TEXT("Bad encoding,no support: : 0x%x"), enc);
					mpg123_delete(m);
					mpg123_exit();
					fclose(fp);
					return FALSE;
				}
				*/
				Log(TEXT("rate: %lu,channels: %d, enc: %d"), rate, channels, enc);
				bits_per_sample = mpg123_encsize(enc) * 8;
				Log(TEXT("bits_per_sample: : %d"), bits_per_sample);
			}
			else
			{
				Log(TEXT("MP3 getformat err: %d"), err);
				mpg123_delete(m);
				mpg123_exit();
				fclose(fp);
				return FALSE;
			}
			
	
			long n = mpg123_length(m) * bits_per_sample * channels / 8;  //通过采样总数*每采样比特数*声道/8获得字节数  
			size_t done = 0;
			buffer = (BYTE*)malloc(n);
	
			err = mpg123_read(m, buffer, n, &done);
	
			if (err != MPG123_OK && err != MPG123_DONE)
			{
				Log(TEXT("MP3 decoder err: %d"), err);
				free(buffer);
				mpg123_delete(m);
				mpg123_exit();
				fclose(fp);
				return FALSE;
			}
	
			Log(TEXT("done: %d"), done);
			
	
			audio.sample_rate = rate;
			audio.channels = channels;
			audio.bits_per_sample = bits_per_sample;
			audio.avg_bytes_sec = rate * bits_per_sample * channels / 8;
			audio.block_align = bits_per_sample / 8 * channels; // i guess... not sure, this mean the bytes of every sample
			audio.data = buffer;
			audio.data_size = done;
			audio.duration = audio.data_size / audio.avg_bytes_sec;//总的播放时间
			audio.size = done + 44 - 8;
	
			char outfname[128] = { 0 };
			changSuffixName(outfname, fname, MP3_SUFFIXNAME, WAV_SUFFIXNAME);
			//char* mp3Str = strstri(fname, ".mp3");
			//if (mp3Str)
			//{
			//	int len = strlen(fname) - strlen(mp3Str);
			//	memcpy(outfname, fname, len);
			//	memcpy(outfname + len, ".wav", 4);
				save_curAudio_2_file(outfname);//20150831-hll
			//}
			mpg123_delete(m);
			mpg123_exit();
			fclose(fp);
			return TRUE;
		}
		else{
			Log(TEXT("Error: MP3 file load error"));
			return FALSE;
		}
	}
	
	bool write_wave_file(char *fname, audioData &audio)
	{
		if (audio.data == 0)
		{
			Log(TEXT("Error: load file first"));
			return FALSE;
		}
	
		FILE *fp;
	
		fp = fopen(fname, "wb");
		if (fp)
		{
			WriteWaveHeader(fp, (int)audio.data_size, (int)audio.sample_rate, (int)audio.channels, (int)audio.bits_per_sample);
			fwrite(audio.data, 1, audio.data_size, fp);
	
			fclose(fp);
	
			return TRUE;
		}
		else
		{
			Log(TEXT("Error: write file open error"));
			return FALSE;
		}
		return FALSE;
	}
	
	bool Audio_tool_kk::load_wave_file(char *fname, audioData &audio)
	{
		FILE *fp;
	
		fp = fopen(fname, "rb");
		if (fp)
		{
			char id[5];          // 'RIFF'and'\0' for strcmp
			unsigned long size;  // file size
	
			short format_tag, channels, block_align, bits_per_sample;    // 16bits
	
			unsigned long format_length, sample_rate, avg_bytes_sec, data_size; // 32bits
	
			fread(id, sizeof(char), 4, fp); // 'RIFF'
			id[4] = '\0';
			Log(TEXT("WAVE id: %c%c%c%c"), id[0], id[1], id[2], id[3]);
	
			if (!strcmp(id, "RIFF"))
			{
				fread(&size, sizeof(unsigned long), 1, fp); // file size
				Log(TEXT("size: %lu"), size);
	
				fread(id, sizeof(char), 4, fp);         // 'WAVE'
				id[4] = '\0';
				Log(TEXT("WAVE id: %c%c%c%c"), id[0], id[1], id[2], id[3]);
	
				if (!strcmp(id, "WAVE"))
				{
					fread(id, sizeof(char), 4, fp);     //  "fmt ";
					//Log(TEXT("WAVE id: %c%c%c%c"), id[0], id[1], id[2], id[3]);
	
					fread(&format_length, sizeof(unsigned long), 1, fp);
					//Log(TEXT("format_length: %lu"), format_length);
	
					fread(&format_tag, sizeof(short), 1, fp); // tag
					//Log(TEXT("format_tag: %d"), format_tag);
	
					fread(&channels, sizeof(short), 1, fp);    // channels
					Log(TEXT("channels: %d"), channels);
	
					fread(&sample_rate, sizeof(unsigned long), 1, fp);   // sample_rate
					Log(TEXT("sample_rate: %lu"), sample_rate);
	
					fread(&avg_bytes_sec, sizeof(unsigned long), 1, fp); // avg_bytes_sec
					Log(TEXT("avg_bytes_sec: %lu"), avg_bytes_sec);
	
					fread(&block_align, sizeof(short), 1, fp);     // block_align
					Log(TEXT("block_align: %d"), block_align);
	
					fread(&bits_per_sample, sizeof(short), 1, fp);       // bits_per_sample
					Log(TEXT("bits_per_sample: %d"), bits_per_sample);
	
					fread(id, sizeof(char), 4, fp);                      // 'data'
	
					fread(&data_size, sizeof(unsigned long), 1, fp);     // data size
					Log(TEXT("data_size: %lu"), data_size);
	
					audio.size = size;
					audio.data_size = data_size;
					audio.data = (BYTE *)malloc(sizeof(BYTE)*data_size);
					fread(audio.data, sizeof(char), data_size, fp);    
	
					audio.format_tag = format_tag;
					audio.channels = channels;
					audio.block_align = block_align;
					audio.bits_per_sample = bits_per_sample;
					audio.format_length = format_length;
					audio.sample_rate = sample_rate;
					audio.avg_bytes_sec = avg_bytes_sec;
					audio.duration = audio.data_size / audio.avg_bytes_sec;//总的播放时间
	
					Log(TEXT("wav load sucess"));
					fclose(fp);
					return TRUE;
				}
				else
				{
					Log(TEXT("Error: RIFF file but not a wave file"));
					fclose(fp);
					return FALSE;
				}
			}
			else
			{
				Log(TEXT("Error: not a RIFF file"));
				fclose(fp);
				return FALSE;
			}
		}
		return FALSE;
	}
	
	void write_16_bits_low_high(FILE * fp, int val)
	{
	    unsigned char bytes[2];
	    bytes[0] = (val & 0xff);
	    bytes[1] = ((val >> 8) & 0xff);
	    fwrite(bytes, 1, 2, fp);
	}
	
	void write_32_bits_low_high(FILE * fp, int val)
	{
	    unsigned char bytes[4];
	    bytes[0] = (val & 0xff);
	    bytes[1] = ((val >> 8) & 0xff);
	    bytes[2] = ((val >> 16) & 0xff);
	    bytes[3] = ((val >> 24) & 0xff);
	    fwrite(bytes, 1, 4, fp);
	}
	
	
	void WriteWaveHeader(FILE * const fp, int pcmbytes, int freq, int channels, int bits)
	{
		int     bytes = (bits + 7) / 8;
		/* quick and dirty, but documented */
		fwrite("RIFF", 1, 4, fp); /* label */
		write_32_bits_low_high(fp, pcmbytes + 44 - 8); /* length in bytes without header */
		fwrite("WAVEfmt ", 2, 4, fp); /* 2 labels */
		write_32_bits_low_high(fp, 2 + 2 + 4 + 4 + 2 + 2); /* length of PCM format declaration area */
		write_16_bits_low_high(fp, 1); /* is PCM? */
		write_16_bits_low_high(fp, channels); /* number of channels */
		write_32_bits_low_high(fp, freq); /* sample frequency in [Hz] */
		write_32_bits_low_high(fp, freq * channels * bytes); /* bytes per second */
		write_16_bits_low_high(fp, channels * bytes); /* bytes per sample time */
		write_16_bits_low_high(fp, bits); /* bits per sample */
		fwrite("data", 1, 4, fp); /* label */
		write_32_bits_low_high(fp, pcmbytes); /* length in bytes of raw PCM data */
	}
	
	int hex_char_value(char c)
	{
		if (c >= '0' && c <= '9')
			return c - '0';
		else if (c >= 'a' && c <= 'f')
			return (c - 'a' + 10);
		else if (c >= 'A' && c <= 'F')
			return (c - 'A' + 10);
		//assert(0);
		return 0;
	}
	int hex_to_decimal(char* szHex)
	{
		int len = 2;
		int result = 0;
		for (int i = 0; i < len; i++)
		{
			result += (int)pow((float)16, (int)len - i - 1) * hex_char_value(szHex[i]);
		}
		return result;
	}
	
	void audioData_normalize_16(BYTE *data, unsigned long dataSize, double *dst)
	{
		for (unsigned long i = 0; i<dataSize; i = i + 2)
		{
			unsigned long low = 0;
			low = data[i];
			//Log(TEXT("    data_low: %lu,%x,%x"), low, low, data[i]);
	
			unsigned long high = 0;
			high = data[i + 1];
			//Log(TEXT("    data_high: %lu,%x,%x"), high, high, data[i + 1]);
	
			double data_true = high * 256 + low;
			//Log(TEXT("    data_true: %f,%x"), data_true, data_true);
	
			double data_complement = 0;
	
			int my_sign = (int)(high / 128);
			//Log(TEXT("    my_sign: %d"), my_sign);
			if (my_sign == 1)
			{
				data_complement = data_true - 65536; //补码
			}
			else
			{
				data_complement = data_true;
			}
			//double db = 20.0f * log10(sqrt(data_complement*data_complement));
			//Log(TEXT("    data_complement: %f"), data_complement);
			double float_data = (double)(data_complement / (double)32768);
			//Log(TEXT("float_data: %f"), float_data);
			int offset = i / 2;
			memcpy(dst + offset, &float_data, sizeof(double));
	
			//Log(TEXT("data[%d]: %f, %f, %f"), i, float_data, dst[offset], db);
	
		}
	}
	
	void audioData_normalize_8(BYTE *data, unsigned long dataSize, double *dst)
	{
		for (unsigned long i = 0; i<dataSize; i = i++)
		{
			unsigned short val = data[i];
			double data_complement = 0;
			/*
			int my_sign = (int)(val / 128);
			if (my_sign == 1)
			{
				data_complement = val - 254; //补码
			}
			else
			{
				data_complement = val;
			}
			*/
	
			data_complement = val - 128;
	
			double float_data = (double)(data_complement / (double)128);
			//Log(TEXT("data[%d]: val:%d, my_sign:%d, data_complement:%f, float_data:%f"), i, val, my_sign, data_complement, float_data);
			memcpy(dst + i, &float_data, sizeof(double));
	
			//Log(TEXT("data[%d]: %f, %f, %f"), i, float_data, dst[offset], db);
	
		}
	}
	
	double mix2mono_float(double c1, double c2)
	{
		//C = A + B - (A * B >> 0x10)
		double val;// = (c1 + c2) / 2;
	
		if (c1 < 0 && c2 < 0)
			val = c1 + c2 - (c1 * c2 / -(pow(2, 16 - 1) - 1));
		else
			val = c1 + c2 - (c1 * c2 / (pow(2, 16 - 1) - 1));
		//Log(TEXT("        c1: %f, c2: %f, val: %f"), c1, c2, val);
	
		val = val*0.51;
	
		if (val > 1)
			val = 1;
		else if (val < -1)
			val = -1;
	
		return val;
	
	}
	
	void mix2mono_normalize(double *normalization_data, unsigned long dataSize, double *dst)
	{
		for (unsigned long i = 0; i < dataSize; i = i + 2)
		{
			double c1 = normalization_data[i];
			double c2 = normalization_data[i + 1];
			//Log(TEXT("data[1]: %f , data[2]: %f, c1: %f, c2: %f"), normalization_data[i], normalization_data[i+1], c1, c2);
			double tmp = mix2mono_float(c1, c2);
			double float_data = tmp;
			int offset = i / 2;
			memcpy(dst + offset, &float_data, sizeof(double));
		}
	}
	
	
	bool Audio_tool_kk::load_wave(char *fname)
	{
		if (audio.data != 0)
			audio.freeAudioData();
	
		if (Audio_tool_kk::load_wave_file(fname, audio))
			return TRUE;
		return FALSE;
	}
	
	bool Audio_tool_kk::load_MP3(char *fname)
	{
		if (audio.data != 0)
		{
			audio.freeAudioData();
		}
	
		if (Audio_tool_kk::load_MP3_file(fname, audio))
			return TRUE;
		return FALSE;
	}
	
	bool Audio_tool_kk::save_curAudio_2_file(char *outfname)
	{
		return write_wave_file(outfname, audio);
	}
	void ChangeFontSize(HDC hdc, int size, COLORREF color)
	{
		LOGFONT lf;
		memset(&lf, 0, sizeof(LOGFONT));
		lf.lfHeight = MulDiv(size, GetDeviceCaps(hdc, LOGPIXELSY), 72);//设置字体的大小
		lf.lfWeight = FW_NORMAL;
		lf.lfCharSet = DEFAULT_CHARSET;
		lf.lfWeight = FW_SEMIBOLD;
		HANDLE hFont = CreateFontIndirect(&lf);
		SelectObject(hdc, hFont);
		SetBkMode(hdc, TRANSPARENT);//绘画文字时以图片背景
		SetTextColor(hdc, color);//设置字体颜色 设置成黄色 
		DeleteObject(hFont);
		//CloseHandle(hFont);
	}
	//bool Audio_tool_kk::drawWaveform(HWND pWnd, HWND pWnd2, HBITMAP hBmp, HBITMAP btm)
	//{
	//	::SendMessage(pWnd, BM_SETIMAGE, (WPARAM)IMAGE_BITMAP, LPARAM(hBmp));
	//	::SendMessage(pWnd2, BM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)btm);
	//
	//	return TRUE;
	//}
	bool Audio_tool_kk::drawWaveform(HWND pWnd, HWND pWnd2, TCHAR* pathName)
	{
		
		HBITMAP hBmp = (HBITMAP)LoadImage(NULL, pathName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_LOADFROMFILE);
		//IDM_VFR
		::SendMessage(pWnd, BM_SETIMAGE, (WPARAM)IMAGE_BITMAP, LPARAM(hBmp));
	
	
		HBITMAP btm = LoadBitmap(hinstMain, MAKEINTRESOURCE(IDB_BITMAP4));
		::SendMessage(pWnd2, BM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)btm);
	
		return TRUE;
	}
	BYTE normalizationTemp[100][4001];
	bool Audio_tool_kk::CreateWaveformBmp(HWND pWnd, int width, int height, char* pathName)//20150723-hll
	{
		if (!pWnd)
		{
			Log(TEXT("cant be null"));
			return FALSE;
		}
		if (!audio.data)
		{
			Log(TEXT("load audio file first,please"));
			return FALSE;
		}
	
		if (audio.channels != 2 && audio.channels != 1)
		{
			Log(TEXT("drawWaveform dont support more than 2 audio channels，audio channels: %s"), audio.channels);
			return FALSE;
		}
	
		unsigned long drawByts_size = 0;
		double *normalization;
	
		HDC hdc = ::GetDC(pWnd);
	
	
		drawByts_size = audio.data_size;
		Log(TEXT("drawByts_size=%x", drawByts_size));
	
		int drawSimple = drawByts_size / width;
		int resimpleCount = width / 10;
		int resimpleRate = drawSimple / resimpleCount;
		for (int i = 0; i < 100; i++)
		{
			memset(normalizationTemp[i], 0x00, 4001);
		}
		int j = 0;
		for (int sc = 0; sc < resimpleCount; sc++){//resmiple
			//Log(TEXT("j=%d"), j);
			j = 0;
			for (int i = 0; i < width ; i++)
			{
				if ((drawSimple*i + sc*resimpleRate) % 2 == 0)
				{
					if (audio.bits_per_sample == 16)
					{
						
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate];
						
						//if (sc==99)
							//Log(TEXT("sc=%d j=%d [sc][j]=%x     %x   %ld"), sc, j, normalizationTemp[sc][j - 1], audio.data[drawSimple*i + sc*resimpleRate], drawSimple*i + sc*resimpleRate);
					
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 1];
						
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 2];
						
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 3];
						
	
						//if (sc == 99)
							//Log(TEXT("sc=%d j=%d [sc][j]=%x     %x   %ld"), sc, j, normalizationTemp[sc][j - 1], audio.data[drawSimple*i + sc*resimpleRate], drawSimple*i + sc*resimpleRate);
					}
					else
					{
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate];
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 1];
						//if (sc==99)
						//Log(TEXT("sc=%d j=%d [sc][j]=%x     %x   %ld"), sc, j, normalizationTemp[sc][j - 1], audio.data[drawSimple*i + sc*resimpleRate], drawSimple*i + sc*resimpleRate);
					}
				}
				else
				{
					if (audio.bits_per_sample == 16)
					{
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 1];
						
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 2];
				
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 3];
						
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 4];
						
						//if (sc == 99)
							//Log(TEXT("sc=%d j=%d [sc][j]=%x     %x   %ld"), sc, j, normalizationTemp[sc][j - 1], audio.data[drawSimple*i + sc*resimpleRate], drawSimple*i + sc*resimpleRate);
	
	
					}
					else
					{
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate+1];
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 2];
						//if (sc==99)
						//Log(TEXT("sc=%d j=%d [sc][j]=%x     %x   %ld"), sc, j, normalizationTemp[sc][j - 1], audio.data[drawSimple*i + sc*resimpleRate], drawSimple*i + sc*resimpleRate);
					}
					
				}
				
			}
		}
		//Log(TEXT("j=%d"), j);
	
		int sizeCount = 0;
		for (int i = 0; i < 100; i++)
		{
			sizeCount += width;
		}
	
		if (audio.bits_per_sample == 16)
		{
			
			BYTE* normalizationByte = (BYTE *)malloc(4 * sizeof(BYTE)*(sizeCount));
			int j=0;
			int n = 0;
			for (int i = 0; i < width; i++)
			{//resmiple
	
				for (int sc = 0; sc < resimpleCount;sc++)
				{
					n = i * 4;
					//if (i < width)
					{
						normalizationByte[j++] = normalizationTemp[sc][n++];
						normalizationByte[j++] = normalizationTemp[sc][n++];
						normalizationByte[j++] = normalizationTemp[sc][n++];
						normalizationByte[j++] = normalizationTemp[sc][n++];
					}
					//else
					//{
					//	break;
					//}
						
					
				}
			}
			Log(TEXT("j=%d"), j);
			Log(TEXT("j=%d"), 4*sizeCount);
	
			drawByts_size = 4 * sizeCount / 2;
			normalization = (double *)malloc(sizeof(double)*drawByts_size);
			memset(normalization, 0, drawByts_size);
	
			audioData_normalize_16(normalizationByte, 4 * sizeCount, normalization);
		}
		else if (audio.bits_per_sample == 8){
	
	
			BYTE* normalizationByte = (BYTE *)malloc(2 * sizeof(BYTE)*(sizeCount));
			int j = 0;
			int n = 0;
			for (int i = 0; i < width; i++)
			{//resmiple
	
				for (int sc = 0; sc < resimpleCount; sc++)
				{
					n = i * 2;
					normalizationByte[j++] = normalizationTemp[sc][n++];
					normalizationByte[j++] = normalizationTemp[sc][n++];
				}
			}
	
			drawByts_size = 2*sizeCount;
			normalization = (double *)malloc(sizeof(double)*drawByts_size);
			memset(normalization, 0, drawByts_size);
	
			audioData_normalize_8(normalizationByte, 2 * sizeCount, normalization);
		}
		else
		{
			::ReleaseDC(pWnd, hdc);
			Log(TEXT("bits per sample must be 8 or 16"));
			return FALSE;
		}
	
	
		if (audio.channels == 2)
		{
			unsigned long afterMin2Mono_size = drawByts_size/2;
			double *afterMin2Mono_normalization = (double *)malloc(sizeof(double)*afterMin2Mono_size);
		
			mix2mono_normalize(normalization, drawByts_size, afterMin2Mono_normalization);
			free(normalization);
			drawByts_size = afterMin2Mono_size;
			normalization = afterMin2Mono_normalization;
		}
	
	
	
		HDC memDC = CreateCompatibleDC(hdc);
		HBITMAP memBM = CreateCompatibleBitmap(hdc, width, height);
		HBITMAP holdBM = (HBITMAP)SelectObject(memDC, memBM);
	
		RECT rect = { 0, 0, width, height - 20 };
		HBRUSH newbrush = CreateSolidBrush(RGB(1, 1, 1));
		HBRUSH oldbrush = (HBRUSH)SelectObject(memDC, newbrush);
		FillRect(memDC, &rect, newbrush);
		SelectObject(memDC, oldbrush);
		DeleteObject(newbrush);
	
		HPEN tPen = CreatePen(PS_SOLID, 2, RGB(255, 255, 255));
		HPEN oPen = (HPEN)SelectObject(memDC, tPen);
		MoveToEx(memDC, 0, height - 20, NULL);
		LineTo(memDC, width, height - 20);
		ChangeFontSize(memDC, 7, RGB(255, 255, 255));
		TCHAR  tempTchr[6];
		for (int i = 1; i < 50; i ++)
		{
			MoveToEx(memDC, 20*i, height - 20, NULL);
			if (i % 2 == 0)
			{
				LineTo(memDC, 20 * i, height - 20 + 6);
				int timeTemp = (20 * i* audio.duration / 1000);
				if (timeTemp / 60 >= 10)
				{
					if (timeTemp % 60 >= 10)
						wsprintf(tempTchr, L"%d:%d", timeTemp / 60, timeTemp % 60);
					else
						wsprintf(tempTchr, L"%d:0%d", timeTemp / 60, timeTemp % 60);
				}
				else
				{
					if (timeTemp % 60 >= 10)
						wsprintf(tempTchr, L"0%d:%d", timeTemp / 60, timeTemp % 60);
					else
						wsprintf(tempTchr, L"0%d:0%d", timeTemp / 60, timeTemp % 60);
				}
				ExtTextOut(memDC, 20 * i - 15, height - 20 + 8, ETO_OPAQUE, NULL, tempTchr, 5, NULL);//20080710
			}
			else
			{
				LineTo(memDC, 20 * i, height - 20 + 3);
			}
	
		}
	
	
		tPen = CreatePen(PS_SOLID, 1, RGB(1, 255, 1));
		oPen = (HPEN)SelectObject(memDC, tPen);
	
		{
			int center = (height - 20) / 2;
			int drawOffset = 0;
			double heightRate = 1.0f / center;
			int scCount = 0;
			if (audio.channels == 2)
			{
				scCount = 100;
			}
			else
			{
				scCount = 200;
			}
			Log(TEXT("drawByts_size=%d"), drawByts_size);
			double val = 0;
			int posy = 0;
			for (int sc = 0; sc < drawByts_size; sc++){//resmiple
				MoveToEx(memDC, sc  / scCount, center, NULL);
				//for (int i = 0; i < width - sc; i++)
				{
	
					//Log(TEXT("data[%d]: %f"), i, normalization[i]);
					val = normalization[sc];
	
					posy = int((double)center - val / heightRate);
					LineTo(memDC, sc  / scCount + drawOffset, posy);
					//Log(TEXT("  [%d]:center = %d, normalization = %f, heightRate = %f,hi =%f, posy = %d "), i, center, val, heightRate, hi, posy);
	
				}
			}
			
		}
	
	
	
	
		SelectObject(memDC, oPen);
		DeleteObject(tPen);
	
		if (normalization)
		free(normalization);
	
	
		BITMAP BmpInfo;
		GetObject(memBM, sizeof(BITMAP), &BmpInfo);//get info
		int datasize = BmpInfo.bmWidthBytes*BmpInfo.bmHeight;
		char*bmp_data = (char*)malloc(datasize);
		if (bmp_data == NULL)
		{
			SelectObject(memDC, holdBM);
			DeleteObject(memBM);
			DeleteObject(memDC);
			::ReleaseDC(NULL, hdc);
			Log(TEXT("bmp_data malloc err"));
			return FALSE;
		}
	
		BITMAPINFO binfo = { 0 };
		BITMAPINFOHEADER *bh = &binfo.bmiHeader;
	
		bh->biBitCount = BmpInfo.bmBitsPixel;//Bits
		bh->biClrImportant = 0;
		bh->biCompression = 0;
		bh->biHeight = height;
		bh->biPlanes = BmpInfo.bmPlanes;//1
		bh->biSize = sizeof(BITMAPINFO);
		bh->biSizeImage = datasize;
		bh->biWidth = width;
		bh->biXPelsPerMeter = 0;
		bh->biYPelsPerMeter = 0;
	
		GetDIBits(memDC, memBM, 0, BmpInfo.bmHeight, bmp_data, &binfo, DIB_RGB_COLORS);//get RGB
	
	
		BITMAPFILEHEADER bfh = { 0 };//head 
		bfh.bfType = MAKEWORD('B', 'M');
		bfh.bfOffBits = sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFO);//heat offset
		bfh.bfSize = bfh.bfOffBits + datasize;//full size
		FILE*fp = fopen(pathName, "wb");
		if (fp == NULL)
		{
			Log(TEXT("tmp bmp write err"));
			return FALSE;
		}
		fwrite(&bfh, 1, sizeof(BITMAPFILEHEADER), fp);
		fwrite(&binfo, 1, sizeof(BITMAPINFO), fp);
		fwrite(bmp_data, 1, BmpInfo.bmWidthBytes*BmpInfo.bmHeight, fp);
		fclose(fp);
	
		free(bmp_data);
		SelectObject(memDC, holdBM);
		DeleteObject(memBM);
		DeleteObject(CreateDIBitmap);
		DeleteObject(memDC);
		DeleteDC(memDC);
	
		::ReleaseDC(pWnd, hdc);
	
	
	
		return TRUE;
	}
	bool Audio_tool_kk::drawWaveform(HWND pWnd, HWND pWnd2, int width, int height)
	{
		if (!pWnd)
		{
			Log(TEXT("cant be null"));
			return FALSE;
		}
		if (!audio.data)
		{
			Log(TEXT("load audio file first,please"));
			return FALSE;
		}
	
		if (audio.channels != 2 && audio.channels != 1)
		{
			Log(TEXT("drawWaveform dont support more than 2 audio channels，audio channels: %s"), audio.channels);
			return FALSE;
		}
	
		unsigned long drawByts_size = 0;
		double *normalization;
	
		HDC hdc = ::GetDC(pWnd);
	
	
		drawByts_size = audio.data_size;
		Log(TEXT("drawByts_size=%x", drawByts_size));
	
		int drawSimple = drawByts_size / width;
		int resimpleCount = width / 10;
		int resimpleRate = drawSimple / resimpleCount;
		for (int i = 0; i < 100; i++)
		{
			memset(normalizationTemp[i], 0x00, 4001);
		}
		int j = 0;
		for (int sc = 0; sc < resimpleCount; sc++){//resmiple
			//Log(TEXT("j=%d"), j);
			j = 0;
			for (int i = 0; i < width; i++)
			{
				if ((drawSimple*i + sc*resimpleRate) % 2 == 0)
				{
					if (audio.bits_per_sample == 16)
					{
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate];
	
						//if (sc == 99)
							//Log(TEXT("sc=%d j=%d [sc][j]=%x     %x   %ld"), sc, j, normalizationTemp[sc][j - 1], audio.data[drawSimple*i + sc*resimpleRate], drawSimple*i + sc*resimpleRate);
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 1];
			
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 2];
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 3];
	
						//if (sc == 99)
							//Log(TEXT("sc=%d j=%d [sc][j]=%x     %x   %ld"), sc, j, normalizationTemp[sc][j - 1], audio.data[drawSimple*i + sc*resimpleRate], drawSimple*i + sc*resimpleRate);
					}
					else
					{
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate];
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 1];
					}
				}
				else
				{
					if (audio.bits_per_sample == 16)
					{
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 1];
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 2];
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 3];
	
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 4];
						//if (sc == 99)
							//Log(TEXT("sc=%d j=%d [sc][j]=%x     %x   %ld"), sc, j, normalizationTemp[sc][j - 1], audio.data[drawSimple*i + sc*resimpleRate], drawSimple*i + sc*resimpleRate);
	
	
					}
					else
					{
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 1];
						normalizationTemp[sc][j++] = audio.data[drawSimple*i + sc*resimpleRate + 2];
					}
	
				}
	
			}
		}
		//Log(TEXT("j=%d"), j);
	
		int sizeCount = 0;
		for (int i = 0; i < 100; i++)
		{
			sizeCount += width;
		}
	
		if (audio.bits_per_sample == 16)
		{
	
			BYTE* normalizationByte = (BYTE *)malloc(4 * sizeof(BYTE)*(sizeCount));
			int j = 0;
			int n = 0;
			for (int i = 0; i < width; i++)
			{//resmiple
	
				for (int sc = 0; sc < resimpleCount; sc++)
				{
					n = i * 4;
					//if (i < width)
					{
						normalizationByte[j++] = normalizationTemp[sc][n++];
						normalizationByte[j++] = normalizationTemp[sc][n++];
						normalizationByte[j++] = normalizationTemp[sc][n++];
						normalizationByte[j++] = normalizationTemp[sc][n++];
					}
					//else
					//{
					//	break;
					//}
	
	
				}
			}
			Log(TEXT("j=%d"), j);
			Log(TEXT("j=%d"), 4 * sizeCount);
	
			drawByts_size = 4 * sizeCount / 2;
			normalization = (double *)malloc(sizeof(double)*drawByts_size);
			memset(normalization, 0, drawByts_size);
	
			audioData_normalize_16(normalizationByte, 4 * sizeCount, normalization);
		}
		else if (audio.bits_per_sample == 8){
	
	
			BYTE* normalizationByte = (BYTE *)malloc(2 * sizeof(BYTE)*(sizeCount));
			int j = 0;
			int n = 0;
			for (int i = 0; i < width; i++)
			{//resmiple
	
				for (int sc = 0; sc < resimpleCount; sc++)
				{
					n = i * 2;
					normalizationByte[j++] = normalizationTemp[sc][n++];
					normalizationByte[j++] = normalizationTemp[sc][n++];
				}
			}
	
			drawByts_size = 2 * sizeCount;
			normalization = (double *)malloc(sizeof(double)*drawByts_size);
			memset(normalization, 0, drawByts_size);
	
			audioData_normalize_8(normalizationByte, 2 * sizeCount, normalization);
		}
		else
		{
			::ReleaseDC(pWnd, hdc);
			Log(TEXT("bits per sample must be 8 or 16"));
			return FALSE;
		}
	
	
		if (audio.channels == 2)
		{
			unsigned long afterMin2Mono_size = drawByts_size / 2;
			double *afterMin2Mono_normalization = (double *)malloc(sizeof(double)*afterMin2Mono_size);
	
			mix2mono_normalize(normalization, drawByts_size, afterMin2Mono_normalization);
			free(normalization);
			drawByts_size = afterMin2Mono_size;
			normalization = afterMin2Mono_normalization;
		}
	
	
	
		HDC memDC = CreateCompatibleDC(hdc);
		HBITMAP memBM = CreateCompatibleBitmap(hdc, width, height);
		HBITMAP holdBM = (HBITMAP)SelectObject(memDC, memBM);
	
		RECT rect = { 0, 0, width, height - 20 };
		HBRUSH newbrush = CreateSolidBrush(RGB(1, 1, 1));
		HBRUSH oldbrush = (HBRUSH)SelectObject(memDC, newbrush);
		FillRect(memDC, &rect, newbrush);
		SelectObject(memDC, oldbrush);
		DeleteObject(newbrush);
	
		HPEN tPen = CreatePen(PS_SOLID, 2, RGB(255, 255, 255));
		HPEN oPen = (HPEN)SelectObject(memDC, tPen);
		MoveToEx(memDC, 0, height - 20, NULL);
		LineTo(memDC, width, height - 20);
		ChangeFontSize(memDC, 7, RGB(255, 255, 255));
		TCHAR  tempTchr[6];
		for (int i = 1; i < 50; i++)
		{
			MoveToEx(memDC, 20 * i, height - 20, NULL);
			if (i % 2 == 0)
			{
				LineTo(memDC, 20 * i, height - 20 + 6);
				int timeTemp = (20 * i* audio.duration / 1000);
				if (timeTemp / 60 >= 10)
				{
					if (timeTemp % 60 >= 10)
						wsprintf(tempTchr, L"%d:%d", timeTemp / 60, timeTemp % 60);
					else
						wsprintf(tempTchr, L"%d:0%d", timeTemp / 60, timeTemp % 60);
				}
				else
				{
					if (timeTemp % 60 >= 10)
						wsprintf(tempTchr, L"0%d:%d", timeTemp / 60, timeTemp % 60);
					else
						wsprintf(tempTchr, L"0%d:0%d", timeTemp / 60, timeTemp % 60);
				}
				ExtTextOut(memDC, 20 * i - 15, height - 20 + 8, ETO_OPAQUE, NULL, tempTchr, 5, NULL);//20080710
			}
			else
			{
				LineTo(memDC, 20 * i, height - 20 + 3);
			}
	
		}
	
	
		tPen = CreatePen(PS_SOLID, 1, RGB(1, 255, 1));
		oPen = (HPEN)SelectObject(memDC, tPen);
	
		{
			int center = (height - 20) / 2;
			int drawOffset = 0;
			double heightRate = 1.0f / center;
			int scCount = 0;
			if (audio.channels == 2)
			{
				scCount = 100;
			}
			else
			{
				scCount = 200;
			}
			Log(TEXT("drawByts_size=%d"), drawByts_size);
			double val = 0;
			int posy = 0;
			for (int sc = 0; sc < drawByts_size; sc++){//resmiple
				MoveToEx(memDC, sc / scCount, center, NULL);
				//for (int i = 0; i < width - sc; i++)
				{
	
					//Log(TEXT("data[%d]: %f"), i, normalization[i]);
					val = normalization[sc];
	
					posy = int((double)center - val / heightRate);
					LineTo(memDC, sc / scCount + drawOffset, posy);
					//Log(TEXT("  [%d]:center = %d, normalization = %f, heightRate = %f,hi =%f, posy = %d "), i, center, val, heightRate, hi, posy);
	
				}
			}
		}
	
	
		SelectObject(memDC, oPen);
		DeleteObject(tPen);
	
		if (normalization)
			free(normalization);
	
	
		BITMAP BmpInfo;
		GetObject(memBM, sizeof(BITMAP), &BmpInfo);//get info
		int datasize = BmpInfo.bmWidthBytes*BmpInfo.bmHeight;
		char*bmp_data = (char*)malloc(datasize);
		if (bmp_data == NULL)
		{
			SelectObject(memDC, holdBM);
			DeleteObject(memBM);
			DeleteObject(memDC);
			::ReleaseDC(NULL, hdc);
			Log(TEXT("bmp_data malloc err"));
			return FALSE;
		}
	
		BITMAPINFO binfo = { 0 };
		BITMAPINFOHEADER *bh = &binfo.bmiHeader;
	
		bh->biBitCount = BmpInfo.bmBitsPixel;//Bits
		bh->biClrImportant = 0;
		bh->biCompression = 0;
		bh->biHeight = height;
		bh->biPlanes = BmpInfo.bmPlanes;//1
		bh->biSize = sizeof(BITMAPINFO);
		bh->biSizeImage = datasize;
		bh->biWidth = width;
		bh->biXPelsPerMeter = 0;
		bh->biYPelsPerMeter = 0;
	
		GetDIBits(memDC, memBM, 0, BmpInfo.bmHeight, bmp_data, &binfo, DIB_RGB_COLORS);//get RGB
	
	
		//HBITMAP hBmp = (HBITMAP)LoadImage(NULL, TEXT(".\\tmp.bmp"), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_LOADFROMFILE);
	
		//IDM_VFR
		::SendMessage(pWnd, BM_SETIMAGE, (WPARAM)IMAGE_BITMAP, LPARAM(CreateDIBitmap(memDC, &binfo.bmiHeader, CBM_INIT, (VOID*)bmp_data, &binfo, DIB_RGB_COLORS)));
	
	
		free(bmp_data);
		SelectObject(memDC, holdBM);
		DeleteObject(memBM);
		DeleteObject(CreateDIBitmap);
		DeleteObject(memDC);
		DeleteDC(memDC);
	
		::ReleaseDC(pWnd, hdc);
	
		HBITMAP btm = LoadBitmap(hinstMain, MAKEINTRESOURCE(IDB_BITMAP4));
		::SendMessage(pWnd2, BM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)btm);
	
		return TRUE;
	}
	
	
	
	void Audio_tool_kk::D3D_init(HWND hwnd, long n)
	{
		//lpPtr1 = new LPVOID;
		//lpPtr2 = new LPVOID;
		//if (g_pD3DSound){ g_pD3DSound->Release(); g_pD3DSound = NULL; }
		DirectSoundCreate(NULL, &g_pD3DSound, NULL);             //创建播放设备  
		g_pD3DSound->SetCooperativeLevel(hwnd, DSSCL_NORMAL);   //设定协同等级，就是缓存的写入级别  
		memset(&dsbd, 0, sizeof(dsbd));
		dsbd.dwSize = sizeof(dsbd);
		dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;                      //这么设置保证在后台也能播放  
		dsbd.dwBufferBytes = n;                                  //解码后的数据大小，以字节计算  
		//dsbd.lpwfxFormat = (WAVEFORMATEX*)malloc(sizeof(WAVEFORMATEX));
	}
	
	void Audio_tool_kk::D3D_cleanUp()
	{
		D3D_play_callback = NULL;
		Log(TEXT("D3D_cleanUp"));
		EnterCriticalSection(&cs);
		Log(TEXT("D3D_cleanUp111"));
		if (g_pD3DSoundBuffer){ g_pD3DSoundBuffer->Release(); g_pD3DSoundBuffer = NULL; }
		if (g_pD3DSound){ g_pD3DSound->Release(); g_pD3DSound = NULL; }
		LeaveCriticalSection(&cs);
		
		
	}
	
	void Audio_tool_kk::D3D_open(audioData& audio)
	{
		//设置音频的格式  
		waveform.wFormatTag = WAVE_FORMAT_PCM;     //PCM类型的声音  
		waveform.nChannels = audio.channels;
		waveform.nSamplesPerSec = audio.sample_rate;
		waveform.nAvgBytesPerSec = audio.avg_bytes_sec;
		waveform.nBlockAlign = audio.block_align;                  
		waveform.wBitsPerSample = audio.bits_per_sample;
		waveform.cbSize = 0;                       //额外信息，一般是0  
	}
	
	void Audio_tool_kk::D3D_play(long n)
	{
		DWORD length1 = 0, length2 = 0, state = 0;
	
		g_pD3DSoundBuffer->SetCurrentPosition(0);    //设定播放位置从0开始  
		g_pD3DSoundBuffer->Play(0, 0, 0);// DSBPLAY_LOOPING);   //播放，循环  
		//等待播放完成  
		g_pD3DSoundBuffer->GetStatus(&state);
	
	
		while ((state == 1) || (state == 5))                        //1代表只放一次，5代表循环播放  
		{
			Sleep(200);                                   //每隔200ms检测一次状态  
			g_pD3DSoundBuffer->GetStatus(&state);
	
			if (isStop)
			{
				g_pD3DSoundBuffer->Stop();
				Sleep(200);
				//g_pD3DSoundBuffer->GetStatus(&state);
				Log(TEXT("break"));
				break;
			}
			//Log(TEXT("playc: %lu   loadc:%lu ,state:%d"), playc, loadc, state);
		}
	}
	
	void Audio_tool_kk::stop()//20150723-hll
	{
		isStop = true;
	}
	
	void Audio_tool_kk::play(HWND hwnd, audioData& audio)
	{
		isStop = false;//20150723-hll
		long n = audio.data_size + audio.sample_rate;
		DWORD length1 = 0, length2 = 0;
	
		//D3D_cleanUp();
		D3D_init(hwnd, n);
		D3D_open(audio);
		dsbd.lpwfxFormat = &waveform;
		//if (g_pD3DSoundBuffer){
		//	g_pD3DSoundBuffer->Release(); g_pD3DSoundBuffer = NULL;
		//}
		g_pD3DSound->CreateSoundBuffer(&dsbd, &g_pD3DSoundBuffer, NULL);
	
		//打开缓存以便写入，返回两个缓存可写入地址和他们的长度，一般来说第二个地址是没有的  
		g_pD3DSoundBuffer->Lock(0, n, &lpPtr1, &length1, &lpPtr2, &length2, 0);
		memcpy(lpPtr1, audio.data, audio.data_size);
		free(audio.data);
		audio.data = NULL;
		g_pD3DSoundBuffer->Unlock(lpPtr1, length1, 0, 0);
		g_pD3DSoundBuffer->Unlock(lpPtr2, length2, 0, 0);
		D3D_play(n);
	
		Audio_tool_kk::D3D_cleanUp();
	}
	
	bool Audio_tool_kk::playCurAudio(HWND hwnd, PLAY_CALLBACK cb)
	{
		if (!audio.data)
		{
			Log(TEXT("error: load audio first"));
			return FALSE;
		}
		Audio_tool_kk::D3D_play_callback = cb;
		Audio_tool_kk::play(hwnd, audio);
		return TRUE;
	}
	int Audio_tool_kk::decodeAacToWave(char* pathName)
	{
		int ret=decodeAacToFile(pathName);
		return ret;
	}
		